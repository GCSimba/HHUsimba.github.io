<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simba</title>
    <link>https://HHUsimba.github.io/</link>
    <description>Recent content on Simba</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 28 Aug 2020 22:59:22 +0800</lastBuildDate>
    
	<atom:link href="https://HHUsimba.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>java基础</title>
      <link>https://HHUsimba.github.io/java/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 28 Aug 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/java%E5%9F%BA%E7%A1%80/</guid>
      <description>基础 【OOP的理解】 OOP是面向对象编程，特征分别是封装、继承、多态、抽象。 可以设计出低耦合的系统，使系统更加灵活、更加易于维护。
封装：封装是指将对象信息状态通过访问权限修饰符隐藏在对象内部，不允许外部程序直接访问，如果外部程序要访问对象内部，可以调用内部提供的get或set方法。
继承：子类继承了父类所有的成员方法和属性，并且可以拥有自己特性。
多态：有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。
重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法
【Object类的常用方法】 hashCode() 的作用是获取哈希码，返回一个 int 整数。哈希码的作用是确定该对象在哈希表中的索引位置。
== : 它的作用是判断两个对象的地址是不是相等。
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
  情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
  情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等
hashCode（）与 equals（）的相关规定
  如果两个对象相等，则 hashcode 一定也是相同的
  两个对象相等,对两个对象分别调用 equals 方法都返回 true
  两个对象有相同的 hashcode 值，它们也不一定是相等的
  因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖
    finalize()：GC在回收对象之前调用该方法，释放内存
toString()返回一个String对象
getClass()返回一个Class对象
wait(),wait(long),wait(long,int),notify(),notifyAll()</description>
    </item>
    
    <item>
      <title>任务执行和调度</title>
      <link>https://HHUsimba.github.io/java/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Sat, 15 Aug 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</guid>
      <description>任务执行和调度 pring框架分别用TaskExecutor和TaskScheduler接口抽象了任务的异步执行和调度。Spring还提供了一些接口的实现，这些接口在应用服务器环境中支持线程池或委托给CommonJ（CommonJ WorkManager）。
Spring还提供了一些集成类来支持与Timer（JDK）和Quartz调度器（Quartz Scheduler https://www.quartz-scheduler.org/）的调度。</description>
    </item>
    
    <item>
      <title>排序算法总结</title>
      <link>https://HHUsimba.github.io/java/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 25 Jul 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>package sort; import java.util.ArrayList; import java.util.Arrays; public class Sort { public static void main(String[] args) { int[] arr = new int[20]; int index = 0; for (int i = 20; i &amp;gt; 0; i--)// 从大到小构建数组 	arr[index++] = i; System.out.println(&amp;#34;原数组：&amp;#34;); System.out.println(Arrays.toString(arr)); System.out.println(&amp;#34;开始排序&amp;#34;); arr = BubbleSort(arr); System.out.println(&amp;#34;BubbleSort排序后为：&amp;#34;); System.out.println(Arrays.toString(arr)); } // 工具：交换数组中元素的位置 	public static int[] swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } // ****** 1.</description>
    </item>
    
    <item>
      <title>项目_社区代码流程</title>
      <link>https://HHUsimba.github.io/java/%E9%A1%B9%E7%9B%AE_%E7%A4%BE%E5%8C%BA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 03 Jul 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E9%A1%B9%E7%9B%AE_%E7%A4%BE%E5%8C%BA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</guid>
      <description>第一部分：首页搭建 一、首页搭建：
1. 数据库建表：user表、comment表、discuss_post表、login_ticket表、user表
2. 创建User、discussPost、Page模型。
3. DiscussPostDAO: 分页查询帖子的数量、查询帖子的行数(方便分页)
DiscussPost-mapper.xml配置DiscussPostDAO映射
UserDao：根据id查user、根据username查user、根据email查询user、adduser、updateStatus、UpdateHeaderUrl、UpdatePassword（注解映射，无需配置mapper）
4. DiscussPostService：getDiscussPosts、findDiscussPostRows
UserService：根据id查用户
5. **HomeController:getIndexPage():**展示首页的内容
第二部分：开发社区登录模块 一、发送邮件：
需求：邮箱设置 -启动客户端SMTP服务，配置邮箱参数，使用javaMailSender发送邮件。
1. 配置邮件客户端：配置application.properties、MailClient类
二、注册功能
需求：访问注册页面 - 点击顶部区域内的链接，打开注册页面。
提交注册数据 - 通过表单提交数据。
- 服务端验证账号是否已存在、邮箱是否已注册。
- 服务端发送激活邮件。
激活注册账号 - 点击邮件中的链接，访问服务端的激活服务。
1. UserDao：addUser
2. 创建CommunityUtil类：生成随机字符串；MD5加密
3. UserService：注册Register
4. LoginController：显示注册页面、实现注册功能
三、邮件激活功能：
1. 创建CommunityConstant常量工具类存储静态常量。
2. **UserService :**激活邮件的功能
3. UserController：获取登录页面的方法、激活邮件的方法。
四、获取验证码：
1. 创建验证码配置类：KaptchaConfig
2. LoginController：生成验证码的方法(/kaptcha)
五、登录功能
1. 创建LoginTicket模型
2. LoginTicketDAO：insertLoginTicket() 、 selectByTicket 、updateStatus
3. UserService:login()、logout
4. LoginController：login登录方法
六、显示登录信息</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://HHUsimba.github.io/java/redis/</link>
      <pubDate>Thu, 25 Jun 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/redis/</guid>
      <description>redis 简介 简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。
用 redis缓存的原因 主要从“高性能”和“高并发”这两点来看待这个问题。
高性能：
假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
高并发：
直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。
用 redis 而不用 map/guava 做缓存的原因 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。
redis 的线程模型 redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。
文件事件处理器的结构包含 4 个部分：
 多个 socket IO 多路复用程序 文件事件分派器 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）  多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</description>
    </item>
    
    <item>
      <title>ArrayList和LinkedList源码</title>
      <link>https://HHUsimba.github.io/java/arraylist%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/</link>
      <pubDate>Tue, 02 Jun 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/arraylist%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/</guid>
      <description>ArrayList /** * Default initial capacity. * ArrayList 默认的数组容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. * 用于空实例的共享空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * 另一个共享空数组实例，用的不多,用于区别上面的EMPTY_ELEMENTDATA */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * The array buffer into which the elements of the ArrayList are stored.</description>
    </item>
    
    <item>
      <title>K Means</title>
      <link>https://HHUsimba.github.io/machine-learning/k-means/</link>
      <pubDate>Mon, 01 Jun 2020 18:53:17 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/k-means/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://HHUsimba.github.io/java/spring/</link>
      <pubDate>Sat, 30 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/spring/</guid>
      <description>Spring中用到的设计模式 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例
讲讲Spring中的IOC与AOP IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
AOP的应用场景
权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
Spring中的编码统一要如何做 配置拦截器
&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; Spring框架 Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的
Spring有哪些模块
Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块
Spring有哪几种配置方式
将Spring配置到应用开发中有以下三种方式：
 基于XML的配置 基于注解的配置 基于Java的配置  Spring Bean的生命周期 Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。
Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。
 初始化之后调用的回调方法。 销毁之前调用的回调方法。  1.Spring代理模式怎么实现的
 Java 动态代理。具体有如下四步骤：
 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。  GCLIB代理</description>
    </item>
    
    <item>
      <title>随机森林计算特征重要性</title>
      <link>https://HHUsimba.github.io/machine-learning/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Sat, 30 May 2020 00:04:23 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>一、方法（1）Mean decrease impurity 对于每颗树，按照impurity（gini /entropy /information gain）给特征排序，然后整个森林取平均。最优条件的选择依据是不纯度。不纯度在分类中通常为Gini不纯度或信息增益/信息熵，对于回归问题来说是方差。
基于不纯度对模型进行排序有几点需要注意： （1）基于不纯度降低的特征选择将会偏向于选择那些具有较多类别的变量（bias）。 （2）当存在相关特征时，一个特征被选择后，与其相关的其他特征的重要度则会变得很低，因为他们可以减少的不纯度已经被前面的特征移除了。
sklearn实现如下：
from sklearn.datasets import load_boston from sklearn.ensemble import RandomForestRegressor import numpy as np #Load boston housing dataset as an example boston = load_boston() X = boston[&amp;#34;data&amp;#34;] print type(X),X.shape Y = boston[&amp;#34;target&amp;#34;] names = boston[&amp;#34;feature_names&amp;#34;] print names rf = RandomForestRegressor() rf.fit(X, Y) print &amp;#34;Features sorted by their score:&amp;#34; print sorted(zip(map(lambda x: round(x, 4), rf.feature_importances_), names), reverse=True) 结果：
Features sorted by their score: [(0.</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://HHUsimba.github.io/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 26 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>一 OSI与TCP/IP各层协议? 1.1 应用层 应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。
域名系统
 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是 www.cisco.com 等。
 HTTP协议
 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）
 1.2 运输层 运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
运输层主要使用以下两种协议:
 传输控制协议 TCP（Transmission Control Protocol）&amp;ndash;提供面向连接的，可靠的数据传输服务。 用户数据协议 UDP（User Datagram Protocol）&amp;ndash;提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。  TCP 与 UDP 的对比见问题三。
1.3 网络层 在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。
这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</description>
    </item>
    
  </channel>
</rss>