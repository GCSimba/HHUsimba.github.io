<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simba</title>
    <link>https://HHUsimba.github.io/</link>
    <description>Recent content on Simba</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 25 Jul 2020 22:59:22 +0800</lastBuildDate>
    
	<atom:link href="https://HHUsimba.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>排序算法总结</title>
      <link>https://HHUsimba.github.io/java/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 25 Jul 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>package sort; import java.util.ArrayList; import java.util.Arrays; public class Sort { public static void main(String[] args) { int[] arr = new int[20]; int index = 0; for (int i = 20; i &amp;gt; 0; i--)// 从大到小构建数组 	arr[index++] = i; System.out.println(&amp;#34;原数组：&amp;#34;); System.out.println(Arrays.toString(arr)); System.out.println(&amp;#34;开始排序&amp;#34;); arr = BubbleSort(arr); System.out.println(&amp;#34;BubbleSort排序后为：&amp;#34;); System.out.println(Arrays.toString(arr)); } // 工具：交换数组中元素的位置 	public static int[] swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } // ****** 1.</description>
    </item>
    
    <item>
      <title>项目_社区代码流程</title>
      <link>https://HHUsimba.github.io/java/%E9%A1%B9%E7%9B%AE_%E7%A4%BE%E5%8C%BA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 03 Jul 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E9%A1%B9%E7%9B%AE_%E7%A4%BE%E5%8C%BA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</guid>
      <description>第一部分：首页搭建 一、首页搭建：
1. 数据库建表：user表、comment表、discuss_post表、login_ticket表、user表
2. 创建User、discussPost、Page模型。
3. DiscussPostDAO: 分页查询帖子的数量、查询帖子的行数(方便分页)
DiscussPost-mapper.xml配置DiscussPostDAO映射
UserDao：根据id查user、根据username查user、根据email查询user、adduser、updateStatus、UpdateHeaderUrl、UpdatePassword（注解映射，无需配置mapper）
4. DiscussPostService：getDiscussPosts、findDiscussPostRows
UserService：根据id查用户
5. **HomeController:getIndexPage():**展示首页的内容
第二部分：开发社区登录模块 一、发送邮件：
需求：邮箱设置 -启动客户端SMTP服务，配置邮箱参数，使用javaMailSender发送邮件。
1. 配置邮件客户端：配置application.properties、MailClient类
二、注册功能
需求：访问注册页面 - 点击顶部区域内的链接，打开注册页面。
提交注册数据 - 通过表单提交数据。
- 服务端验证账号是否已存在、邮箱是否已注册。
- 服务端发送激活邮件。
激活注册账号 - 点击邮件中的链接，访问服务端的激活服务。
1. UserDao：addUser
2. 创建CommunityUtil类：生成随机字符串；MD5加密
3. UserService：注册Register
4. LoginController：显示注册页面、实现注册功能
三、邮件激活功能：
1. 创建CommunityConstant常量工具类存储静态常量。
2. **UserService :**激活邮件的功能
3. UserController：获取登录页面的方法、激活邮件的方法。
四、获取验证码：
1. 创建验证码配置类：KaptchaConfig
2. LoginController：生成验证码的方法(/kaptcha)
五、登录功能
1. 创建LoginTicket模型
2. LoginTicketDAO：insertLoginTicket() 、 selectByTicket 、updateStatus
3. UserService:login()、logout
4. LoginController：login登录方法
六、显示登录信息</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://HHUsimba.github.io/java/redis/</link>
      <pubDate>Thu, 25 Jun 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/redis/</guid>
      <description>redis 简介 简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。
用 redis缓存的原因 主要从“高性能”和“高并发”这两点来看待这个问题。
高性能：
假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
高并发：
直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。
用 redis 而不用 map/guava 做缓存的原因 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。
redis 的线程模型 redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。
文件事件处理器的结构包含 4 个部分：
 多个 socket IO 多路复用程序 文件事件分派器 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）  多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</description>
    </item>
    
    <item>
      <title>ArrayList和LinkedList源码</title>
      <link>https://HHUsimba.github.io/java/arraylist%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/</link>
      <pubDate>Tue, 02 Jun 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/arraylist%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/</guid>
      <description>ArrayList /** * Default initial capacity. * ArrayList 默认的数组容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. * 用于空实例的共享空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * 另一个共享空数组实例，用的不多,用于区别上面的EMPTY_ELEMENTDATA */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * The array buffer into which the elements of the ArrayList are stored.</description>
    </item>
    
    <item>
      <title>K Means</title>
      <link>https://HHUsimba.github.io/machine-learning/k-means/</link>
      <pubDate>Mon, 01 Jun 2020 18:53:17 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/k-means/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://HHUsimba.github.io/java/spring/</link>
      <pubDate>Sat, 30 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/spring/</guid>
      <description>Spring中用到的设计模式 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例
讲讲Spring中的IOC与AOP IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
AOP的应用场景
权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
Spring中的编码统一要如何做 配置拦截器
&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; Spring框架 Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的
Spring有哪些模块
Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块
Spring有哪几种配置方式
将Spring配置到应用开发中有以下三种方式：
 基于XML的配置 基于注解的配置 基于Java的配置  Spring Bean的生命周期 Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。
Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。
 初始化之后调用的回调方法。 销毁之前调用的回调方法。  1.Spring代理模式怎么实现的
 Java 动态代理。具体有如下四步骤：
 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。  GCLIB代理</description>
    </item>
    
    <item>
      <title>随机森林计算特征重要性</title>
      <link>https://HHUsimba.github.io/machine-learning/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Sat, 30 May 2020 00:04:23 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>一、方法（1）Mean decrease impurity 对于每颗树，按照impurity（gini /entropy /information gain）给特征排序，然后整个森林取平均。最优条件的选择依据是不纯度。不纯度在分类中通常为Gini不纯度或信息增益/信息熵，对于回归问题来说是方差。
基于不纯度对模型进行排序有几点需要注意： （1）基于不纯度降低的特征选择将会偏向于选择那些具有较多类别的变量（bias）。 （2）当存在相关特征时，一个特征被选择后，与其相关的其他特征的重要度则会变得很低，因为他们可以减少的不纯度已经被前面的特征移除了。
sklearn实现如下：
from sklearn.datasets import load_boston from sklearn.ensemble import RandomForestRegressor import numpy as np #Load boston housing dataset as an example boston = load_boston() X = boston[&amp;#34;data&amp;#34;] print type(X),X.shape Y = boston[&amp;#34;target&amp;#34;] names = boston[&amp;#34;feature_names&amp;#34;] print names rf = RandomForestRegressor() rf.fit(X, Y) print &amp;#34;Features sorted by their score:&amp;#34; print sorted(zip(map(lambda x: round(x, 4), rf.feature_importances_), names), reverse=True) 结果：
Features sorted by their score: [(0.</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://HHUsimba.github.io/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 26 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>一 OSI与TCP/IP各层协议? 1.1 应用层 应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。
域名系统
 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是 www.cisco.com 等。
 HTTP协议
 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）
 1.2 运输层 运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
运输层主要使用以下两种协议:
 传输控制协议 TCP（Transmission Control Protocol）&amp;ndash;提供面向连接的，可靠的数据传输服务。 用户数据协议 UDP（User Datagram Protocol）&amp;ndash;提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。  TCP 与 UDP 的对比见问题三。
1.3 网络层 在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。
这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://HHUsimba.github.io/java/linux/</link>
      <pubDate>Tue, 26 May 2020 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/linux/</guid>
      <description>ps：操作系统复习，参考java-guide整理
 一 Linux 1.1 Linux简介  类Unix系统： Linux是一种自由、开放源码的类似Unix的操作系统 Linux内核： 严格来说，Linux这个词本身只表示Linux内核  1.2 Linux的分类 Linux根据原生程度，分为两种：
 内核版本： Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等； 发行版本： 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。  二 Linux文件系统 2.1 Linux文件系统简介 在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。
也就是说在LINUX系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。
2.2 Inode inode是linux/unix文件系统和硬盘存储的基础，如果理解了inode， 将会对我们学习如何将复杂的概念抽象成简单概念有重大帮助。
Inode含义及作用 文件存储在硬盘上，硬盘的最小存储单位是扇区(Sector),每个扇区存储512字节(0.5kb)。操作系统读取硬盘的数据时，不会一个扇区一个扇区的读取，这样做效率较低，而是一次读取多个扇区，即一次读取一个块(block)。块由多个扇区组成，是文件读取的最小单位，块的最常见的大小是4kb，约为8个连续的扇区组成。文件数据存储在块中，但还需要一个空间来存储文件的元信息metadata，如文件拥有者，创建时间，权限，大小等。 这种存储文件元信息的区域就叫inode，译为索引节点。 每个文件都有一个inode，存储文件的元信息。使用 stat 命令可以查看文件的inode信息。每个inode都有一个号码，Linux/Unix操作系统不使用文件名来区分文件，而是使用inode号码区分不同的文件。
inode也需要消耗硬盘空间，所以在格式化硬盘的时候，操作系统会将硬盘分为2个区域，一个区域存放文件数据，另一个区域存放inode所包含的信息，存放inode的区域被称为inode table。
文件的inode信息:
2.3 文件类型与目录结构 **Linux支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
  普通文件: 普通文件是指txt,html,pdf等等的这样应用层面的文件类型， 用户可以根据访问权限对普通文件进行访问，修改和删除。
  目录文件: 目录也是一种文件，打开目录实际上是打开目录文件。 目录文件包含了它目录下的所有文件名以及指向这些文件的指针。
  链接文件: 链接文件分为符号链接(软链接)文件和硬链接文件
  硬链接(Hard Link):硬链接的文件拥有相同的inode，因为操作系统是靠inode来区分文件的， 2个inode相同的文件，就代表它们是一个文件。 删除一个文件并不会对其他拥有相同inode的文件产生影响，只有当inode相同的所有文件被删除了， 这个文件才会被删除。换言之，你建立一个文件的硬链接，这个文件和硬链接它们的inode是相同的, 无论你删除的是硬链接还是源文件，都不会对彼此造成影响,除非你把硬链接和源文件都删除， 这个文件才被删除。
  符号链接(软链接)(Symbolic Link): 符号链接类似于Windows上的快捷方式，它保存了源文件的路径。 当符号链接被删除时，并不会影响源文件。但是当源文件被删除时，符号链接就找不到源文件了。</description>
    </item>
    
    <item>
      <title>This引用逃逸</title>
      <link>https://HHUsimba.github.io/java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</link>
      <pubDate>Tue, 26 May 2020 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</guid>
      <description>This逃逸含义 在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题。
例如：
1 /** 2 * 模拟this逃逸 3 * @author Lijian 4 * 5 */ 6 public class ThisEscape { 7 //final常量会保证在构造器内完成初始化（但是仅限于未发生this逃逸的情况下，具体可以看多线程对final保证可见性的实现）  8 final int i; 9 //尽管实例变量有初始值，但是还实例化完成 10 int j = 0; 11 static ThisEscape obj; 12 public ThisEscape() { 13 i=1; 14 j=1; 15 //将this逃逸抛出给线程B 16 obj = new ThisEscape(); 17 } 18 public static void main(String[] args) { 19 //线程A：模拟构造器中this逃逸,将未构造完全对象引用抛出 20 /*Thread threadA = new Thread(new Runnable() { 21 @Override 22 public void run() { 23 //obj = new ThisEscape(); 24 } 25 });*/ 26 //线程B：读取对象引用，访问i/j变量 27 Thread threadB = new Thread(new Runnable() { 28 @Override 29 public void run() { 30 31 //可能会发生初始化失败的情况解释：实例变量i的初始化被重排序到构造器外，此时1还未被初始化 32 ThisEscape objB = obj; 33 try { 34 System.</description>
    </item>
    
  </channel>
</rss>