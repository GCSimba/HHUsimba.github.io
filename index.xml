<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simba</title>
    <link>https://HHUsimba.github.io/</link>
    <description>Recent content on Simba</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 01 Jun 2020 18:53:17 +0800</lastBuildDate>
    
	<atom:link href="https://HHUsimba.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>K Means</title>
      <link>https://HHUsimba.github.io/machine-learning/k-means/</link>
      <pubDate>Mon, 01 Jun 2020 18:53:17 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/k-means/</guid>
      <description></description>
    </item>
    
    <item>
      <title>随机森林计算特征重要性</title>
      <link>https://HHUsimba.github.io/machine-learning/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Sat, 30 May 2020 00:04:23 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>一、方法（1）Mean decrease impurity 对于每颗树，按照impurity（gini /entropy /information gain）给特征排序，然后整个森林取平均。最优条件的选择依据是不纯度。不纯度在分类中通常为Gini不纯度或信息增益/信息熵，对于回归问题来说是方差。
基于不纯度对模型进行排序有几点需要注意： （1）基于不纯度降低的特征选择将会偏向于选择那些具有较多类别的变量（bias）。 （2）当存在相关特征时，一个特征被选择后，与其相关的其他特征的重要度则会变得很低，因为他们可以减少的不纯度已经被前面的特征移除了。
sklearn实现如下：
from sklearn.datasets import load_boston from sklearn.ensemble import RandomForestRegressor import numpy as np #Load boston housing dataset as an example boston = load_boston() X = boston[&amp;#34;data&amp;#34;] print type(X),X.shape Y = boston[&amp;#34;target&amp;#34;] names = boston[&amp;#34;feature_names&amp;#34;] print names rf = RandomForestRegressor() rf.fit(X, Y) print &amp;#34;Features sorted by their score:&amp;#34; print sorted(zip(map(lambda x: round(x, 4), rf.feature_importances_), names), reverse=True) 结果：
Features sorted by their score: [(0.</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://HHUsimba.github.io/java/linux/</link>
      <pubDate>Tue, 26 May 2020 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/linux/</guid>
      <description>ps：操作系统复习，参考java-guide整理
 一 Linux 1.1 Linux简介  类Unix系统： Linux是一种自由、开放源码的类似Unix的操作系统 Linux内核： 严格来说，Linux这个词本身只表示Linux内核  1.2 Linux的分类 Linux根据原生程度，分为两种：
 内核版本： Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等； 发行版本： 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。  二 Linux文件系统 2.1 Linux文件系统简介 在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。
也就是说在LINUX系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。
2.2 Inode inode是linux/unix文件系统和硬盘存储的基础，如果理解了inode， 将会对我们学习如何将复杂的概念抽象成简单概念有重大帮助。
Inode含义及作用 文件存储在硬盘上，硬盘的最小存储单位是扇区(Sector),每个扇区存储512字节(0.5kb)。操作系统读取硬盘的数据时，不会一个扇区一个扇区的读取，这样做效率较低，而是一次读取多个扇区，即一次读取一个块(block)。块由多个扇区组成，是文件读取的最小单位，块的最常见的大小是4kb，约为8个连续的扇区组成。文件数据存储在块中，但还需要一个空间来存储文件的元信息metadata，如文件拥有者，创建时间，权限，大小等。 这种存储文件元信息的区域就叫inode，译为索引节点。 每个文件都有一个inode，存储文件的元信息。使用 stat 命令可以查看文件的inode信息。每个inode都有一个号码，Linux/Unix操作系统不使用文件名来区分文件，而是使用inode号码区分不同的文件。
inode也需要消耗硬盘空间，所以在格式化硬盘的时候，操作系统会将硬盘分为2个区域，一个区域存放文件数据，另一个区域存放inode所包含的信息，存放inode的区域被称为inode table。
文件的inode信息:
2.3 文件类型与目录结构 **Linux支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
  普通文件: 普通文件是指txt,html,pdf等等的这样应用层面的文件类型， 用户可以根据访问权限对普通文件进行访问，修改和删除。
  目录文件: 目录也是一种文件，打开目录实际上是打开目录文件。 目录文件包含了它目录下的所有文件名以及指向这些文件的指针。
  链接文件: 链接文件分为符号链接(软链接)文件和硬链接文件
  硬链接(Hard Link):硬链接的文件拥有相同的inode，因为操作系统是靠inode来区分文件的， 2个inode相同的文件，就代表它们是一个文件。 删除一个文件并不会对其他拥有相同inode的文件产生影响，只有当inode相同的所有文件被删除了， 这个文件才会被删除。换言之，你建立一个文件的硬链接，这个文件和硬链接它们的inode是相同的, 无论你删除的是硬链接还是源文件，都不会对彼此造成影响,除非你把硬链接和源文件都删除， 这个文件才被删除。
  符号链接(软链接)(Symbolic Link): 符号链接类似于Windows上的快捷方式，它保存了源文件的路径。 当符号链接被删除时，并不会影响源文件。但是当源文件被删除时，符号链接就找不到源文件了。</description>
    </item>
    
    <item>
      <title>This引用逃逸</title>
      <link>https://HHUsimba.github.io/java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</link>
      <pubDate>Tue, 26 May 2020 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</guid>
      <description>This逃逸含义 在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题。
例如：
1 /** 2 * 模拟this逃逸 3 * @author Lijian 4 * 5 */ 6 public class ThisEscape { 7 //final常量会保证在构造器内完成初始化（但是仅限于未发生this逃逸的情况下，具体可以看多线程对final保证可见性的实现）  8 final int i; 9 //尽管实例变量有初始值，但是还实例化完成 10 int j = 0; 11 static ThisEscape obj; 12 public ThisEscape() { 13 i=1; 14 j=1; 15 //将this逃逸抛出给线程B 16 obj = new ThisEscape(); 17 } 18 public static void main(String[] args) { 19 //线程A：模拟构造器中this逃逸,将未构造完全对象引用抛出 20 /*Thread threadA = new Thread(new Runnable() { 21 @Override 22 public void run() { 23 //obj = new ThisEscape(); 24 } 25 });*/ 26 //线程B：读取对象引用，访问i/j变量 27 Thread threadB = new Thread(new Runnable() { 28 @Override 29 public void run() { 30 31 //可能会发生初始化失败的情况解释：实例变量i的初始化被重排序到构造器外，此时1还未被初始化 32 ThisEscape objB = obj; 33 try { 34 System.</description>
    </item>
    
    <item>
      <title>应用场景 气象预报</title>
      <link>https://HHUsimba.github.io/machine-learning/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%E6%B0%94%E8%B1%A1%E9%A2%84%E6%8A%A5/</link>
      <pubDate>Wed, 21 Nov 2018 10:47:06 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%E6%B0%94%E8%B1%A1%E9%A2%84%E6%8A%A5/</guid>
      <description>应用场景：气象预报 1. 预报类别（按照时间）    预报类别 时间     临近预报 0-2小时内   短临预报 2-12小时内   短期预报 1-3天   中期预报 3-15天   长期预报 15天以上    参考：中国气象局官网、临近预报
http://www.cma.gov.cn/2011xwzx/2011xqxxw/2011xqxyw/201408/t20140822_258683.html
https://baike.baidu.com/item/%E4%B8%B4%E8%BF%91%E9%A2%84%E6%8A%A5/5021658
2. 预报类别（按照方法） </description>
    </item>
    
    <item>
      <title>降雨预测方法</title>
      <link>https://HHUsimba.github.io/machine-learning/%E9%99%8D%E9%9B%A8%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 21 Nov 2018 10:47:06 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/%E9%99%8D%E9%9B%A8%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95/</guid>
      <description>降雨预测方法   DBNPF (Deep Belief Network for Precipitation Forecast) 来源：张雷师兄论文：A deep-learning based precipitation forecasting
  模型： 比较：RBF、SVM、ARIMA、ELM（extreme learning machine）、SAE（Sparse AutoEncoder） 数据集： 遵义市1956-2010
train data:1956-2000
test data:2000-2010
  动态区域组合MLP 来源：贾旸旸师兄论文：Short-term Rainfall Forecasting Using Multi-layer Perceptron
  模型： PCA：13个物理因子进行降维，输入到MLP中
贪婪算法决定MLP的结构，
该模型的初始数据包括五个高空因素和八个地表因素。
在气象学中，通常用位势高度代替实际高度，用等压面代替水平高度，因此，气象数据总是采用等压面格式。例如，500hpa通常相当于5.5km的高度。降雨系统通常由500hpa的天气系统控制。根据区域经验，该模型选择的五个海拔因子分别是500hpa高度下的实际高度（x1）、温度（x2）、温度露点差（x3）、风向（x4）和风速（x5）。风向和风速影响着降雨系统的运动方向和速度。温度露点差与湿度直接相关。温度露点差、温度和实际高度值影响着降雨系统的内能。地表因子代表该地区的局部大气条件。不同地区地表因子的差异导致降雨不同。该模型中所用的八个面因子包括总云量（X6）、地表风速（X7）、地面风向（X8）、地面气压（X9）、地表3小时压力变化（X10）、地表温度露点差（X11）、地表温度（X12）和过去三小时的降雨。周围区域（x13）。对于同一个预测区域，每个周边区域都与该预测区域建立一个MLP。表1显示了所有13个因素。这些因素是我们模型的初始输入。
最小-最大规范化。最常用的数据规范化方法之一是最小-最大规范化。它可以在0和1之间标准化数据。由于不同因素的大小不同，有必要对数据进行预处理。对于要处理的序列，序列的最大值对应于1，最小值对应于0，其余值在0和1之间按比例转换。
主成分分析。归一化后，PCA用于减小输入的维数。确定新因子个数的标准是99%，即所选因子的特征值之和占总特征值的99%以上。经计算，新因子的总信息可以代表原始数据的99%以上。此标准定义了保留的信息量，但没有指定所需的因子数量。对于不同的预测区域，因子的数量可能不同，但不会超过初始输入，即13。在大多数情况下，需要的因素数量在3到8之间。PCA处理后，所需的计算资源大大减少。
MLP的输入是Z1-Z4四个参数，输出是降雨量
step1:
step2:中心预测点与其他地区各有一个MLP，两个地区的距离决定了周围MLP的数量。周围多个MLP模型一起决策，如果预测降雨的MLP超过1，取均值。
比较： 数据集： 2015-2017年海拔（500hPa）测绘数据和数值预报结果。
train data:2015-2016
test data:2016-2017
  基于雷达回波图像的短期降雨预测 来源：基于雷达回波图像的短期降雨预测
  模型： 卷积自编码器的编码模块首先提取每帧输入图像特征，送入LSTM预报网络；LSTM预报网络的编码模块，对输入信息提取时序特征，在此基础上，由LSTM预测模块产生关于未来时段回波图像时序特征预测。
比较： 在MINIST数据集上对自编码器的层数和LSTM层数预测效果进行对比
数据集： 石家庄地区 2010 -2017 年之间降雨天气的雷达回波图像 。</description>
    </item>
    
    <item>
      <title>Latex技巧总结</title>
      <link>https://HHUsimba.github.io/machine-learning/latex%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 03 Sep 2018 08:46:13 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/latex%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</guid>
      <description>导包: 在LaTex中有专门的导包的地方：   修改表格线条粗细\hline
step1: 用 \usepackage{booktabs} 导包 step2: 首行: \toprule[1pt] 中间行：\midrule[1pt] 尾行：\midrule[1pt]
  表格内容对齐：
\begin{tabular}{c} c:center r:right l:left
  Latex添加新一页 用“\clearpage” 不要用“\newpage”
  调整表格列间距
\begin{tabular}{|p{1cm}|p{2cm}|p{3cm}|}   图表位置移动
\begin{table}[!htb] 首先，!表示无视美学规则，按下面的要求放置； 然后h t b p分别代表4中放置方式，优先级依次递减。 可以自己定优先级，tbhp等 常用选项[htbp]是浮动格式： h=here 放置在代码中这个图片出现的位置，也就是你想让它出现的位置； t = top 放在该页顶端； b = bottom 放在该页底部； p = page浮动页。将图形放置在一只允许有浮动对象的页面上。 一般使用[htb]这样的组合，只用[h]是没有用的。这样组合的意思就是latex会尽量满足排在前面的浮动格	式，就是h-t-b这个顺序，让排版的效果尽量好。
!h 只是试图放在当前位置。如果页面剩下的部分放不下，还是会跑到下一页的。一般页言，用 [!h] 选项经常会出现不能正确放置的问题，所以常用 [ht]、[htbp] 等。
  增大表格行距
\begin{document} \renewcommand\arraystretch{2} //作用是讲每一行的高度变为原来的两倍。 \begin{table}[h] \centering   表格内容调整</description>
    </item>
    
    <item>
      <title>Python安装tips</title>
      <link>https://HHUsimba.github.io/machine-learning/python%E5%AE%89%E8%A3%85tips/</link>
      <pubDate>Wed, 23 May 2018 00:04:23 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/machine-learning/python%E5%AE%89%E8%A3%85tips/</guid>
      <description>一、包的安装   Windows下使用pip安装快速方法：
#some-package为你想要安装的包的名字 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package #安装指定的版本的包 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package==版本号   在cmd下复制粘贴方法：
step1: 进入cmd后右键窗口→属性→编辑选项→快速编辑模式√
step2: 复制选中代码，右键cmd命令行处，回车
  二、机器学习常用包 ​	按照以下顺序安装：
​	1、numpy、scipy
​	2、pandas
​	3、matplotlib
​	4、scikit-learn工具包
​	5、Theano深度学习</description>
    </item>
    
    <item>
      <title></title>
      <link>https://HHUsimba.github.io/java/aqs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://HHUsimba.github.io/java/aqs/</guid>
      <description>类加载器与双亲委派模型 类加载器 类加载器（ClassLoader）是Java语言的一项创新，也是Java流行的一个重要原因。在类加载的第一阶段“加载”过程中，需要通过一个类的全限定名来获取定义此类的二进制字节流，完成这个动作的代码块就是类加载器。这一动作是放在Java虚拟机外部去实现的，以便让应用程序自己决定如何获取所需的类。
从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。
从开发者的角度，类加载器可以细分为：
  启动（Bootstrap）类加载器：负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。
  标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。
  应用程序（Application）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。
  除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。
双亲委派模型过程 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。
———————————————— 参考：《深入理解JVM》</description>
    </item>
    
    <item>
      <title>不忘初心，方得始终</title>
      <link>https://HHUsimba.github.io/%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83%E6%96%B9%E5%BE%97%E5%A7%8B%E7%BB%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://HHUsimba.github.io/%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83%E6%96%B9%E5%BE%97%E5%A7%8B%E7%BB%88/</guid>
      <description>对于未来的焦虑让我开始不断的充实自己，
我希望在这里能够记录我的点点滴滴，
有所始，有所终，
愿最后自己能够成为一个想成为的人！</description>
    </item>
    
  </channel>
</rss>