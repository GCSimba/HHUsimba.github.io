<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Spring">
<meta itemprop="description" content="Spring中用到的设计模式 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例
讲讲Spring中的IOC与AOP IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
AOP的应用场景
权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
Spring中的编码统一要如何做 配置拦截器
&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Spring框架 Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的
Spring有哪些模块
Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块
Spring有哪几种配置方式
将Spring配置到应用开发中有以下三种方式：
 基于XML的配置 基于注解的配置 基于Java的配置  Spring Bean的生命周期 Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。
Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。
 初始化之后调用的回调方法。 销毁之前调用的回调方法。  1.Spring代理模式怎么实现的
 Java 动态代理。具体有如下四步骤：
 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。  GCLIB代理">
<meta itemprop="datePublished" content="2020-05-30T22:59:22&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-30T22:59:22&#43;08:00" />
<meta itemprop="wordCount" content="400">



<meta itemprop="keywords" content="" /><meta property="og:title" content="Spring" />
<meta property="og:description" content="Spring中用到的设计模式 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例
讲讲Spring中的IOC与AOP IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
AOP的应用场景
权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
Spring中的编码统一要如何做 配置拦截器
&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Spring框架 Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的
Spring有哪些模块
Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块
Spring有哪几种配置方式
将Spring配置到应用开发中有以下三种方式：
 基于XML的配置 基于注解的配置 基于Java的配置  Spring Bean的生命周期 Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。
Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。
 初始化之后调用的回调方法。 销毁之前调用的回调方法。  1.Spring代理模式怎么实现的
 Java 动态代理。具体有如下四步骤：
 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。  GCLIB代理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://HHUsimba.github.io/java/spring/" />
<meta property="article:published_time" content="2020-05-30T22:59:22+08:00" />
<meta property="article:modified_time" content="2020-05-30T22:59:22+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring"/>
<meta name="twitter:description" content="Spring中用到的设计模式 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例
讲讲Spring中的IOC与AOP IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
AOP的应用场景
权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
Spring中的编码统一要如何做 配置拦截器
&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Spring框架 Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的
Spring有哪些模块
Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块
Spring有哪几种配置方式
将Spring配置到应用开发中有以下三种方式：
 基于XML的配置 基于注解的配置 基于Java的配置  Spring Bean的生命周期 Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。
Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。
 初始化之后调用的回调方法。 销毁之前调用的回调方法。  1.Spring代理模式怎么实现的
 Java 动态代理。具体有如下四步骤：
 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。  GCLIB代理"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Spring</title>
	<link rel="stylesheet" href="https://HHUsimba.github.io/css/style.min.657bcb7af31123e4156b1a3d2ff60a636717e54ead74f882136b5114cf72b55e.css" integrity="sha256-ZXvLevMRI+QVaxo9L/YKY2cX5U6tdPiCE2tRFM9ytV4=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://HHUsimba.github.io/">Simba</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://HHUsimba.github.io/java/">Java</a>
				<a href="https://HHUsimba.github.io/machine-learning/">Machine Learning</a>
				<a href="https://HHUsimba.github.io/%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83%E6%96%B9%E5%BE%97%E5%A7%8B%E7%BB%88/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://space.bilibili.com/10246091" target="_blank" rel="noopener me" title="Bilibili"><svg xmlns="http://www.w3.org/2000/svg" class="feather feather-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://HHUsimba.github.io/java/">Java</a></li>
			<li><a href="https://HHUsimba.github.io/machine-learning/">Machine Learning</a></li>
			<li><a href="https://HHUsimba.github.io/%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83%E6%96%B9%E5%BE%97%E5%A7%8B%E7%BB%88/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>Spring</h1>
		<div class="content">
			<h4 id="spring中用到的设计模式">Spring中用到的设计模式<a href="#spring中用到的设计模式" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>工厂模式:IOC容器
代理模式:AOP
策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的
单例模式:默认情况下spring中的bean只存在一个实例</p>
<h4 id="讲讲spring中的ioc与aop">讲讲Spring中的IOC与AOP<a href="#讲讲spring中的ioc与aop" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。
AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。</p>
<p>AOP的应用场景</p>
<p>权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。</p>
<h4 id="spring中的编码统一要如何做">Spring中的编码统一要如何做<a href="#spring中的编码统一要如何做" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>配置拦截器</p>
<pre><code>&lt;filter&gt;  
       &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;  
       &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  
       &lt;init-param&gt;  
           &lt;param-name&gt;encoding&lt;/param-name&gt;  
           &lt;param-value&gt;UTF-8&lt;/param-value&gt;  
       &lt;/init-param&gt;  
       &lt;init-param&gt;  
           &lt;param-name&gt;forceEncoding&lt;/param-name&gt;  
           &lt;param-value&gt;true&lt;/param-value&gt;  
       &lt;/init-param&gt;  
   &lt;/filter&gt;  
   &lt;filter-mapping&gt;  
       &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;  
       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  
   &lt;/filter-mapping&gt;
</code></pre><h4 id="spring框架">Spring框架<a href="#spring框架" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的</p>
<p>Spring有哪些模块</p>
<p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块</p>
<p>Spring有哪几种配置方式</p>
<p>将Spring配置到应用开发中有以下三种方式：</p>
<ol>
<li>基于XML的配置</li>
<li>基于注解的配置</li>
<li>基于Java的配置</li>
</ol>
<h4 id="spring-bean的生命周期">Spring Bean的生命周期<a href="#spring-bean的生命周期" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。</p>
<p>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。</p>
<ol>
<li>初始化之后调用的回调方法。</li>
<li>销毁之前调用的回调方法。</li>
</ol>
<p>1.Spring代理模式怎么实现的</p>
<hr>
<p>Java 动态代理。具体有如下四步骤：</p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ol>
<p>GCLIB代理</p>
<p>　　cglib（Code Generation Library）是一个强大的,高性能,高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。
　　cglib封装了asm，可以在运行期动态生成新的class。
　　cglib用于AOP，jdk中的proxy必须基于接口，cglib却没有这个限制。</p>
<p>原理区别：</p>
<p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP
3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p>
<p>2.Spring声明事务管理</p>
<p>​       声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。</p>
<p>3.Spring框架有哪些模块？</p>
<p>Spring框架的基本模块如下所示：</p>
<ul>
<li>Core module</li>
<li>Bean module</li>
<li>Context module</li>
<li>Expression Language module</li>
<li>JDBC module</li>
<li>ORM module</li>
<li>OXM module</li>
<li>Java Messaging Service(JMS) module</li>
<li>Transaction module</li>
<li>Web module</li>
<li>Web-Servlet module</li>
<li>Web-Struts module</li>
<li>Web-Portlet module</li>
</ul>
<hr>
<p>4.解释核心容器(应用上下文)模块</p>
<p>这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。</p>
<hr>
<p>5.BeanFactory – BeanFactory 实例</p>
<p>BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。</p>
<p>最常用的BeanFactory实现是XmlBeanFactory类。</p>
<hr>
<p>6.XmlBeanFactory</p>
<p>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。</p>
<hr>
<p>7.解释AOP模块</p>
<p>AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。</p>
<hr>
<p>8.解释抽象JDBC和DAO模块</p>
<p>通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。</p>
<hr>
<p>9.解释对象/关系映射集成模块</p>
<p>Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。</p>
<hr>
<p>10.解释web模块</p>
<p>Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。</p>
<hr>
<p>11.解释Spring MVC模块</p>
<p>Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。</p>
<hr>
<p>12.Spring的配置文件</p>
<p>Spring的配置文件是一个XML文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。</p>
<hr>
<p>13.Spring IoC容器是什么？</p>
<p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。</p>
<hr>
<p>14.IOC有什么优点？</p>
<p>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</p>
<hr>
<p>15.应用上下文是如何实现的？</p>
<p><strong>FileSystemXmlApplicationContext</strong> 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。</p>
<p><strong>FileSystemXmlApplicationContext</strong> 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。</p>
<p>**WebXmlApplicationContext：**该容器加载xml文件，这些文件定义了web应用中所有的beans。</p>
<hr>
<p>16.Bean Factory和ApplicationContext？</p>
<p>ApplicationContext提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。另外，容器或者容器中beans的操作，这些必须以bean工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了MessageSource，该接口用于获取本地消息，实际的实现是可选的。</p>
<hr>
<p>17.Spring应用程序看起来像什么？</p>
<ul>
<li>一个定义功能的接口</li>
<li>实现包括属性，setter和getter方法，功能等</li>
<li>Spring AOP</li>
<li>Spring的XML配置文件</li>
<li>使用该功能的客户端编程</li>
</ul>
<p><strong>依赖注入</strong></p>
<hr>
<p>18.Spring中的依赖注入是什么？</p>
<p>依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。</p>
<hr>
<p>19.有哪些不同类型的IOC(依赖注入)？</p>
<ul>
<li>**构造器依赖注入：**构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。</li>
<li>**Setter方法依赖注入：**首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。</li>
</ul>
<hr>
<p>20.你推荐哪种依赖注入？</p>
<p>你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。</p>
<p><strong>Spring Beans</strong></p>
<hr>
<p>21.什么是Spring Beans？</p>
<p>Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。</p>
<p>在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。</p>
<hr>
<p>22.Spring Bean中定义了什么内容？</p>
<p>Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p>
<hr>
<p>23.如何向Spring 容器提供配置元数据？</p>
<p>有三种方式向Spring 容器提供元数据:</p>
<ul>
<li>XML配置文件</li>
<li>基于注解配置</li>
<li>基于Java的配置</li>
</ul>
<hr>
<p>24.你如何定义bean的作用域？</p>
<p>在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候通过’scope’属性定义即可。例如，当Spring需要产生每次一个新的bean实例时，应该声明bean的scope属性为prototype。如果每次你希望Spring返回一个实例，应该声明bean的scope属性为singleton。</p>
<hr>
<p>25.说一下Spring中支持的bean作用域</p>
<p>Spring框架支持如下五种不同的作用域：</p>
<ul>
<li><strong>singleton</strong>：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。</li>
<li><strong>prototype</strong>：一个bean可以定义多个实例。</li>
<li><strong>request</strong>：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。</li>
<li><strong>session</strong>：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境.</li>
<li><strong>globalSession</strong>：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境.</li>
</ul>
<p>bean默认的scope属性是’<strong>singleton</strong>‘。</p>
<hr>
<p>26.Spring框架单例beans线程安全吗？</p>
<p>不是，Spring框架中的单例beans不是线程安全的。</p>
<hr>
<p>27.解释Spring框架中bean的生命周期</p>
<ul>
<li>Spring容器读取XML文件中bean的定义并实例化bean。</li>
<li>Spring根据bean的定义设置属性值。</li>
<li>如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。</li>
<li>如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。</li>
<li>如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。</li>
<li>如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方法。</li>
<li>如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。</li>
<li>如果该bean实现了DisposableBean，调用destroy()方法。</li>
</ul>
<hr>
<p>28.哪些是最重要的bean生命周期方法？</p>
<p>有两个重要的bean生命周期方法。第一个是setup方法，该方法在容器加载bean的时候被调用。第二个是teardown方法，该方法在bean从容器中移除的时候调用。</p>
<p>bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。</p>
<hr>
<p>29.什么是Spring的内部bean？</p>
<p>当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。</p>
<hr>
<p>30.如何在Spring中注入Java集合类？</p>
<p>Spring提供如下几种类型的集合配置元素：</p>
<ul>
<li>list元素用来注入一系列的值，允许有相同的值。</li>
<li>set元素用来注入一些列的值，不允许有相同的值。</li>
<li>map用来注入一组”键-值”对，键、值可以是任何类型的。</li>
<li>props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。</li>
</ul>
<hr>
<p>31.什么是bean wiring？</p>
<p>Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。</p>
<hr>
<p>32.什么是bean自动装配？</p>
<p>Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和&lt; property&gt;元素。</p>
<hr>
<p>33.解释自动装配的各种模式？</p>
<p>自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入:</p>
<ul>
<li>**no：**默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。</li>
<li>**byName：**通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li>
<li>**byType：**通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。</li>
<li>**constructor：**这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。</li>
<li>**autodetect：**如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li>
</ul>
<hr>
<p>34.自动装配有哪些局限性？</p>
<p>自动装配有如下局限性：</p>
<ul>
<li>**重写：**你仍然需要使用 和&lt; property&gt;设置指明依赖，这意味着总要重写自动装配。</li>
<li>**原生数据类型:**你不能自动装配简单的属性，如原生类型、字符串和类。</li>
<li>**模糊特性：**自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。</li>
</ul>
<hr>
<p>35.可以在Spring中注入null或空字符串吗</p>
<p>完全可以。</p>
<p><strong>Spring注解</strong></p>
<hr>
<p>36.什么是Spring基于Java的配置？</p>
<p>基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。</p>
<p>以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。</p>
<hr>
<p>37.什么是基于注解的容器配置?</p>
<p>另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。</p>
<hr>
<p>38.如何开启注解装配？</p>
<p>注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。</p>
<hr>
<p>39.@Required 注解</p>
<p>@Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。</p>
<hr>
<p>40.@Autowired 注解</p>
<p>@Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<hr>
<ol start="41">
<li>@Qualifier 注解</li>
</ol>
<p>当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。</p>
<p><strong>Spring数据访问</strong></p>
<hr>
<p>42.Spring框架中如何有效的使用JDBC</p>
<p>使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate(例子)。</p>
<hr>
<p>43.JdbcTemplate</p>
<p>JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。</p>
<hr>
<p>44.Spring对DAO的支持</p>
<p>Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。</p>
<hr>
<p>45.通过什么方式访问Hibernate？</p>
<p>使用Spring有两种方式访问Hibernate：</p>
<ul>
<li>使用Hibernate Template的反转控制以及回调方法</li>
<li>继承HibernateDAOSupport，并申请一个AOP拦截器节点</li>
</ul>
<hr>
<p>46.Spring支持的ORM</p>
<p>Spring支持一下ORM：</p>
<ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA (Java -Persistence API)</li>
<li>TopLink</li>
<li>JDO (Java Data Objects)</li>
<li>OJB</li>
</ul>
<hr>
<p>47.Spring和Hibernate结合起来</p>
<p>使用Spring的SessionFactory 调用LocalSessionFactory。结合过程分为以下三步：</p>
<ul>
<li>配置Hibernate SessionFactory</li>
<li>继承HibernateDaoSupport实现一个DAO</li>
<li>使用AOP装载事务支持</li>
</ul>
<hr>
<p>48.Spring支持的事务管理类型</p>
<p>Spring支持如下两种方式的事务管理：</p>
<ul>
<li>**编程式事务管理：**这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>
<li>**声明式事务管理：**这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</li>
</ul>
<hr>
<p>49.Spring框架的事务管理有哪些优点？</p>
<ul>
<li>它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。</li>
<li>它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).</li>
<li>它支持声明式事务管理。</li>
<li>它可以和Spring 的多种数据访问技术很好的融合。</li>
</ul>
<hr>
<p>50.你更推荐那种类型的事务管理？</p>
<p>许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。</p>
<p><strong>Spring面向切面编程(AOP)</strong></p>
<hr>
<p>51.解释AOP</p>
<p>面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。</p>
<hr>
<p>52.切面(Aspect)</p>
<p>AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。</p>
<hr>
<p>53.concern和 cross-cutting concern</p>
<p>Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。</p>
<p>Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。</p>
<hr>
<p>54.连接点(Join point)</p>
<p>连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。</p>
<hr>
<p>55.通知(Advice)</p>
<p>通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。</p>
<p>Spring切面可以执行一下五种类型的通知:</p>
<ul>
<li>before(前置通知)：在一个方法之前执行的通知。</li>
<li>after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li>
<li>after-returning(后置通知)：在某连接点正常完成后执行的通知。</li>
<li>after-throwing(异常通知)：在方法抛出异常退出时执行的通知。</li>
<li>around(环绕通知)：在方法调用前后触发的通知。</li>
</ul>
<hr>
<p>56.切入点(Pointcut)</p>
<p>切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p>
<hr>
<p>57.什么是引入？</p>
<p>引入允许我们在已有的类上添加新的方法或属性。</p>
<hr>
<p>58.什么是目标对象？</p>
<p>被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。</p>
<hr>
<p>59.什么是代理？</p>
<p>代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</p>
<hr>
<p>60.有几种不同类型的自动代理？</p>
<ul>
<li>BeanNameAutoProxyCreator：bean名称自动代理创建器</li>
<li>DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器</li>
<li>Metadata autoproxying：元数据自动代理</li>
</ul>
<hr>
<p>61.什么是织入应用的不同点？</p>
<p>织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。</p>
<hr>
<p>62.解释基于XML Schema方式的切面实现</p>
<p>在这种情况下，切面由使用XML文件配置的类实现。</p>
<hr>
<p>63.基于注解方式(基于@AspectJ)的切面</p>
<p>在这种情况下(基于@AspectJ的实现)，指的是切面的对应的类使用Java 5注解的声明方式。</p>
<p><strong>Spring的MVC框架</strong></p>
<hr>
<p>64.什么是Spring的MVC框架？</p>
<p>Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。</p>
<hr>
<p>65.DispatcherServlet</p>
<p>Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
<hr>
<p>66.WebApplicationContext</p>
<p>WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。</p>
<hr>
<p>67.什么是Spring MVC框架的控制器？</p>
<p>控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。</p>
<hr>
<p>68.@Controller annotation</p>
<p>@Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。</p>
<hr>
<p>69.@RequestMapping annotation</p>
<p>@RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。</p>

		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://HHUsimba.github.io/">simba</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://HHUsimba.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://HHUsimba.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
