<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javas on Simba</title>
    <link>https://HHUsimba.github.io/java/</link>
    <description>Recent content in Javas on Simba</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 26 May 2020 19:41:04 +0800</lastBuildDate>
    
	<atom:link href="https://HHUsimba.github.io/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux</title>
      <link>https://HHUsimba.github.io/java/linux/</link>
      <pubDate>Tue, 26 May 2020 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/linux/</guid>
      <description>ps：操作系统复习，参考java-guide整理
 一 Linux 1.1 Linux简介  类Unix系统： Linux是一种自由、开放源码的类似Unix的操作系统 Linux内核： 严格来说，Linux这个词本身只表示Linux内核  1.2 Linux的分类 Linux根据原生程度，分为两种：
 内核版本： Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等； 发行版本： 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。  二 Linux文件系统 2.1 Linux文件系统简介 在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。
也就是说在LINUX系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。
2.2 Inode inode是linux/unix文件系统和硬盘存储的基础，如果理解了inode， 将会对我们学习如何将复杂的概念抽象成简单概念有重大帮助。
Inode含义及作用 文件存储在硬盘上，硬盘的最小存储单位是扇区(Sector),每个扇区存储512字节(0.5kb)。操作系统读取硬盘的数据时，不会一个扇区一个扇区的读取，这样做效率较低，而是一次读取多个扇区，即一次读取一个块(block)。块由多个扇区组成，是文件读取的最小单位，块的最常见的大小是4kb，约为8个连续的扇区组成。文件数据存储在块中，但还需要一个空间来存储文件的元信息metadata，如文件拥有者，创建时间，权限，大小等。 这种存储文件元信息的区域就叫inode，译为索引节点。 每个文件都有一个inode，存储文件的元信息。使用 stat 命令可以查看文件的inode信息。每个inode都有一个号码，Linux/Unix操作系统不使用文件名来区分文件，而是使用inode号码区分不同的文件。
inode也需要消耗硬盘空间，所以在格式化硬盘的时候，操作系统会将硬盘分为2个区域，一个区域存放文件数据，另一个区域存放inode所包含的信息，存放inode的区域被称为inode table。
文件的inode信息:
2.3 文件类型与目录结构 **Linux支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
  普通文件: 普通文件是指txt,html,pdf等等的这样应用层面的文件类型， 用户可以根据访问权限对普通文件进行访问，修改和删除。
  目录文件: 目录也是一种文件，打开目录实际上是打开目录文件。 目录文件包含了它目录下的所有文件名以及指向这些文件的指针。
  链接文件: 链接文件分为符号链接(软链接)文件和硬链接文件
  硬链接(Hard Link):硬链接的文件拥有相同的inode，因为操作系统是靠inode来区分文件的， 2个inode相同的文件，就代表它们是一个文件。 删除一个文件并不会对其他拥有相同inode的文件产生影响，只有当inode相同的所有文件被删除了， 这个文件才会被删除。换言之，你建立一个文件的硬链接，这个文件和硬链接它们的inode是相同的, 无论你删除的是硬链接还是源文件，都不会对彼此造成影响,除非你把硬链接和源文件都删除， 这个文件才被删除。
  符号链接(软链接)(Symbolic Link): 符号链接类似于Windows上的快捷方式，它保存了源文件的路径。 当符号链接被删除时，并不会影响源文件。但是当源文件被删除时，符号链接就找不到源文件了。</description>
    </item>
    
    <item>
      <title>This引用逃逸</title>
      <link>https://HHUsimba.github.io/java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</link>
      <pubDate>Tue, 26 May 2020 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</guid>
      <description>This逃逸含义 在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题。
例如：
1 /** 2 * 模拟this逃逸 3 * @author Lijian 4 * 5 */ 6 public class ThisEscape { 7 //final常量会保证在构造器内完成初始化（但是仅限于未发生this逃逸的情况下，具体可以看多线程对final保证可见性的实现）  8 final int i; 9 //尽管实例变量有初始值，但是还实例化完成 10 int j = 0; 11 static ThisEscape obj; 12 public ThisEscape() { 13 i=1; 14 j=1; 15 //将this逃逸抛出给线程B 16 obj = new ThisEscape(); 17 } 18 public static void main(String[] args) { 19 //线程A：模拟构造器中this逃逸,将未构造完全对象引用抛出 20 /*Thread threadA = new Thread(new Runnable() { 21 @Override 22 public void run() { 23 //obj = new ThisEscape(); 24 } 25 });*/ 26 //线程B：读取对象引用，访问i/j变量 27 Thread threadB = new Thread(new Runnable() { 28 @Override 29 public void run() { 30 31 //可能会发生初始化失败的情况解释：实例变量i的初始化被重排序到构造器外，此时1还未被初始化 32 ThisEscape objB = obj; 33 try { 34 System.</description>
    </item>
    
    <item>
      <title>类加载器和双亲委派模型</title>
      <link>https://HHUsimba.github.io/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 26 May 2020 13:59:53 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</guid>
      <description>类加载器 类加载器（ClassLoader）是Java语言的一项创新，也是Java流行的一个重要原因。在类加载的第一阶段“加载”过程中，需要通过一个类的全限定名来获取定义此类的二进制字节流，完成这个动作的代码块就是类加载器。这一动作是放在Java虚拟机外部去实现的，以便让应用程序自己决定如何获取所需的类。
从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。
从开发者的角度，类加载器可以细分为：
  启动（Bootstrap）类加载器：负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。
  标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。
  应用程序（Application）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。
  除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。
双亲委派模型过程 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</description>
    </item>
    
    <item>
      <title>GC笔记</title>
      <link>https://HHUsimba.github.io/java/gc%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 03 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/gc%E7%AC%94%E8%AE%B0/</guid>
      <description>1 判断对象已经死亡 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。 1.1 引用计数法 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。
public class ReferenceCountingGc { Object instance = null; public static void main(String[] args) { ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; } } 1.2 可达性分析算法 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 1.3 引用 无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。 JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。 JDK1.</description>
    </item>
    
    <item>
      <title>MySQL设计</title>
      <link>https://HHUsimba.github.io/java/mysql%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 02 Apr 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/mysql%E8%AE%BE%E8%AE%A1/</guid>
      <description>外键和级联 简单系统可以使用，分布式，高并发不适合采用
阿里巴巴开发手册：
 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
说明:以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风 险;外键影响数据库的插入速度
 外键缺点
  增加了复杂性： a.每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便;b.外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。 增加了额外工作： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。） 外键还会因为需要请求对其他表内部加锁而容易出现死锁情况； 对分库分表不友好 ：因为分库分表下外键是无法生效的。   简单系统使用外键的好处：
 保证了数据库数据的一致性和完整性； 级联操作方便，减轻了程序代码量； &amp;hellip;&amp;hellip;  如果系统不涉及分不分表，并发量不是很高的情况还是可以考虑使用外键的。
参考：https://blog.csdn.net/lidaasky/article/details/7645524，《阿里java开发手册》</description>
    </item>
    
    <item>
      <title>MySQL设计规范</title>
      <link>https://HHUsimba.github.io/java/mysql%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</link>
      <pubDate>Thu, 02 Apr 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/mysql%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</guid>
      <description>外键和级联 简单系统可以使用，分布式，高并发不适合采用
阿里巴巴开发手册：
 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
说明:以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风 险;外键影响数据库的插入速度
 外键缺点
  增加了复杂性： a.每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便;b.外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。 增加了额外工作： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。） 外键还会因为需要请求对其他表内部加锁而容易出现死锁情况； 对分库分表不友好 ：因为分库分表下外键是无法生效的。   简单系统使用外键的好处：
 保证了数据库数据的一致性和完整性； 级联操作方便，减轻了程序代码量； &amp;hellip;&amp;hellip;  如果系统不涉及分不分表，并发量不是很高的情况还是可以考虑使用外键的。
参考：https://blog.csdn.net/lidaasky/article/details/7645524，《阿里java开发手册》</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://HHUsimba.github.io/java/git/</link>
      <pubDate>Sun, 22 Mar 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/git/</guid>
      <description>部署： cd public git add . git commit -m &amp;ldquo;yyyy/mm/dd-hh:mm&amp;rdquo; git push -u origin master
更新： 用git工具执行，每次在根目录 输入hugo 初始化一下 hugo
然后进入public文档 cd public
打开git Bash here相继输入以下代码 git init(如果报fatal: not a git repository (or any of the parent directories): .git) git add -A git commit -m &amp;ldquo;xxxx&amp;rdquo; git push -f origin master
创建md hugo new posts/text1.md 创建文件夹 hugo new site 文件名称 (如blog)</description>
    </item>
    
    <item>
      <title>ArrayList扩容机制</title>
      <link>https://HHUsimba.github.io/java/arraylist%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 13 Jan 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/arraylist%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</guid>
      <description>ArrayList简述 ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长。 ArrayList不是线程安全的，只能用在单线程环境下。 实现了Serializable接口，因此它支持序列化，能够通过序列化传输； 实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问； 实现了Cloneable接口，能被克隆。
动态扩容 1.初始化 三种创建方式
public ArrayList(); 默认的构造器，将会以默认的大小来初始化内部的数组
public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) 用一个Collection对象来构造，并将该集合的元素添加到ArrayList
public ArrayList(int initialCapacity) 用指定的大小来初始化内部的数组
2.确保内部容量 初始化时，数组长度为0
ensureCapacityInternal方法名的英文大致是“确保内部容量”，size表示的是执行添加之前的元素个数，并非ArrayList的容量，容量应该是数组elementData的长度。ensureCapacityInternal该方法通过将现有的元素个数数组的容量比较。看如果需要扩容，则扩容。
public boolean add(E e) { //确保内部容量(通过判断，如果够则不进行操作；容量不够就扩容来确保内部容量)  ensureCapacityInternal(size + 1); // ①Increments modCount!!  elementData[size++] = e;//②  return true; } 3.扩容 如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时，才真正分配容量。每次按照1.5倍（位运算）的比率通过copeOf的方式扩容。 在JKD1.6中实现是，如果通过无参构造的话，初始数组容量为10，每次通过copeOf的方式扩容后容量为原来的1.5倍，以上就是动态扩容的原理。
ArrayList相当于在没指定initialCapacity时就是会使用延迟分配对象数组空间，当第一次插入元素时才分配10（默认）个对象空间。假如有20个数据需要添加，那么会分别在第一次的时候，将ArrayList的容量变为10 (如下图一)；之后扩容会按照1.5倍增长。也就是当添加第11个数据的时候，Arraylist继续扩容变为10*1.5=15(如下图二)；当添加第16个数据时，继续扩容变为15 * 1.5 =22个。</description>
    </item>
    
    <item>
      <title>AQS笔记</title>
      <link>https://HHUsimba.github.io/java/aqs%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 02 Dec 2019 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/aqs%E7%AC%94%E8%AE%B0/</guid>
      <description>1、AQS简介 AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向链表。
Sync queue：同步队列，是一个双向链表。包括head节点和tail节点。head节点主要用作后续的调度。 Condition queue：非必须，单向链表。当程序中存在cindition的时候才会存在此列表。
AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。
状态信息通过procted类型的getState，setState，compareAndSetState进行操作
//返回同步状态的当前值 protected final int getState() { return state; } // 设置同步状态的值 protected final void setState(int newState) { state = newState; } //原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值） protected final boolean compareAndSetState(int expect, int update) { return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } 2、AQS设计思想 使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。
利用int类型标识状态。在AQS类中有一个叫做state的成员变量
/** The synchronization state. */ private volatile int state;基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。   基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。
  继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。
  可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：独占和共享。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。
  3、AQS的大致实现思路 AQS内部维护了一个CLH队列来管理锁。线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里。 接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://HHUsimba.github.io/java/mysql/</link>
      <pubDate>Sun, 26 May 2019 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/mysql/</guid>
      <description>常见命令 查看MySQL提供的所有存储引擎
mysql&amp;gt; show engines; MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。
查看MySQL当前默认的存储引擎
mysql&amp;gt; show variables like &amp;#39;%storage_engine%&amp;#39;; 查看表的存储引擎
show table status like &amp;#34;table_name&amp;#34; ; MyISAM和InnoDB区别 MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。
大多数时候使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。
两者的对比：
 是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。 是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 是否支持外键： MyISAM不支持，而InnoDB支持。 是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。  《MySQL高性能》:
 不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</description>
    </item>
    
  </channel>
</rss>