<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javas on Simba</title>
    <link>https://HHUsimba.github.io/java/</link>
    <description>Recent content in Javas on Simba</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 03 Jul 2020 22:59:22 +0800</lastBuildDate>
    
	<atom:link href="https://HHUsimba.github.io/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>项目_社区代码流程</title>
      <link>https://HHUsimba.github.io/java/%E9%A1%B9%E7%9B%AE_%E7%A4%BE%E5%8C%BA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 03 Jul 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E9%A1%B9%E7%9B%AE_%E7%A4%BE%E5%8C%BA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</guid>
      <description>第一部分：首页搭建 一、首页搭建：
1. 数据库建表：user表、comment表、discuss_post表、login_ticket表、user表
2. 创建User、discussPost、Page模型。
3. DiscussPostDAO: 分页查询帖子的数量、查询帖子的行数(方便分页)
DiscussPost-mapper.xml配置DiscussPostDAO映射
UserDao：根据id查user、根据username查user、根据email查询user、adduser、updateStatus、UpdateHeaderUrl、UpdatePassword（注解映射，无需配置mapper）
4. DiscussPostService：getDiscussPosts、findDiscussPostRows
UserService：根据id查用户
5. **HomeController:getIndexPage():**展示首页的内容
第二部分：开发社区登录模块 一、发送邮件：
需求：邮箱设置 -启动客户端SMTP服务，配置邮箱参数，使用javaMailSender发送邮件。
1. 配置邮件客户端：配置application.properties、MailClient类
二、注册功能
需求：访问注册页面 - 点击顶部区域内的链接，打开注册页面。
提交注册数据 - 通过表单提交数据。
- 服务端验证账号是否已存在、邮箱是否已注册。
- 服务端发送激活邮件。
激活注册账号 - 点击邮件中的链接，访问服务端的激活服务。
1. UserDao：addUser
2. 创建CommunityUtil类：生成随机字符串；MD5加密
3. UserService：注册Register
4. LoginController：显示注册页面、实现注册功能
三、邮件激活功能：
1. 创建CommunityConstant常量工具类存储静态常量。
2. **UserService :**激活邮件的功能
3. UserController：获取登录页面的方法、激活邮件的方法。
四、获取验证码：
1. 创建验证码配置类：KaptchaConfig
2. LoginController：生成验证码的方法(/kaptcha)
五、登录功能
1. 创建LoginTicket模型
2. LoginTicketDAO：insertLoginTicket() 、 selectByTicket 、updateStatus
3. UserService:login()、logout
4. LoginController：login登录方法
六、显示登录信息</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://HHUsimba.github.io/java/redis/</link>
      <pubDate>Thu, 25 Jun 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/redis/</guid>
      <description>redis 简介 简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。
用 redis缓存的原因 主要从“高性能”和“高并发”这两点来看待这个问题。
高性能：
假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
高并发：
直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。
用 redis 而不用 map/guava 做缓存的原因 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。
redis 的线程模型 redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。
文件事件处理器的结构包含 4 个部分：
 多个 socket IO 多路复用程序 文件事件分派器 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）  多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</description>
    </item>
    
    <item>
      <title>ArrayList和LinkedList源码</title>
      <link>https://HHUsimba.github.io/java/arraylist%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/</link>
      <pubDate>Tue, 02 Jun 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/arraylist%E5%92%8Clinkedlist%E6%BA%90%E7%A0%81/</guid>
      <description>ArrayList /** * Default initial capacity. * ArrayList 默认的数组容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. * 用于空实例的共享空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * 另一个共享空数组实例，用的不多,用于区别上面的EMPTY_ELEMENTDATA */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * The array buffer into which the elements of the ArrayList are stored.</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://HHUsimba.github.io/java/spring/</link>
      <pubDate>Sat, 30 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/spring/</guid>
      <description>Spring中用到的设计模式 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例
讲讲Spring中的IOC与AOP IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
AOP的应用场景
权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。
Spring中的编码统一要如何做 配置拦截器
&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; Spring框架 Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的
Spring有哪些模块
Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块
Spring有哪几种配置方式
将Spring配置到应用开发中有以下三种方式：
 基于XML的配置 基于注解的配置 基于Java的配置  Spring Bean的生命周期 Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。
Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。
 初始化之后调用的回调方法。 销毁之前调用的回调方法。  1.Spring代理模式怎么实现的
 Java 动态代理。具体有如下四步骤：
 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。  GCLIB代理</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://HHUsimba.github.io/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 26 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>一 OSI与TCP/IP各层协议? 1.1 应用层 应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。
域名系统
 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是 www.cisco.com 等。
 HTTP协议
 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）
 1.2 运输层 运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
运输层主要使用以下两种协议:
 传输控制协议 TCP（Transmission Control Protocol）&amp;ndash;提供面向连接的，可靠的数据传输服务。 用户数据协议 UDP（User Datagram Protocol）&amp;ndash;提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。  TCP 与 UDP 的对比见问题三。
1.3 网络层 在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。
这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://HHUsimba.github.io/java/linux/</link>
      <pubDate>Tue, 26 May 2020 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/linux/</guid>
      <description>ps：操作系统复习，参考java-guide整理
 一 Linux 1.1 Linux简介  类Unix系统： Linux是一种自由、开放源码的类似Unix的操作系统 Linux内核： 严格来说，Linux这个词本身只表示Linux内核  1.2 Linux的分类 Linux根据原生程度，分为两种：
 内核版本： Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等； 发行版本： 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。  二 Linux文件系统 2.1 Linux文件系统简介 在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。
也就是说在LINUX系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。
2.2 Inode inode是linux/unix文件系统和硬盘存储的基础，如果理解了inode， 将会对我们学习如何将复杂的概念抽象成简单概念有重大帮助。
Inode含义及作用 文件存储在硬盘上，硬盘的最小存储单位是扇区(Sector),每个扇区存储512字节(0.5kb)。操作系统读取硬盘的数据时，不会一个扇区一个扇区的读取，这样做效率较低，而是一次读取多个扇区，即一次读取一个块(block)。块由多个扇区组成，是文件读取的最小单位，块的最常见的大小是4kb，约为8个连续的扇区组成。文件数据存储在块中，但还需要一个空间来存储文件的元信息metadata，如文件拥有者，创建时间，权限，大小等。 这种存储文件元信息的区域就叫inode，译为索引节点。 每个文件都有一个inode，存储文件的元信息。使用 stat 命令可以查看文件的inode信息。每个inode都有一个号码，Linux/Unix操作系统不使用文件名来区分文件，而是使用inode号码区分不同的文件。
inode也需要消耗硬盘空间，所以在格式化硬盘的时候，操作系统会将硬盘分为2个区域，一个区域存放文件数据，另一个区域存放inode所包含的信息，存放inode的区域被称为inode table。
文件的inode信息:
2.3 文件类型与目录结构 **Linux支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
  普通文件: 普通文件是指txt,html,pdf等等的这样应用层面的文件类型， 用户可以根据访问权限对普通文件进行访问，修改和删除。
  目录文件: 目录也是一种文件，打开目录实际上是打开目录文件。 目录文件包含了它目录下的所有文件名以及指向这些文件的指针。
  链接文件: 链接文件分为符号链接(软链接)文件和硬链接文件
  硬链接(Hard Link):硬链接的文件拥有相同的inode，因为操作系统是靠inode来区分文件的， 2个inode相同的文件，就代表它们是一个文件。 删除一个文件并不会对其他拥有相同inode的文件产生影响，只有当inode相同的所有文件被删除了， 这个文件才会被删除。换言之，你建立一个文件的硬链接，这个文件和硬链接它们的inode是相同的, 无论你删除的是硬链接还是源文件，都不会对彼此造成影响,除非你把硬链接和源文件都删除， 这个文件才被删除。
  符号链接(软链接)(Symbolic Link): 符号链接类似于Windows上的快捷方式，它保存了源文件的路径。 当符号链接被删除时，并不会影响源文件。但是当源文件被删除时，符号链接就找不到源文件了。</description>
    </item>
    
    <item>
      <title>This引用逃逸</title>
      <link>https://HHUsimba.github.io/java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</link>
      <pubDate>Tue, 26 May 2020 19:41:04 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</guid>
      <description>This逃逸含义 在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题。
例如：
1 /** 2 * 模拟this逃逸 3 * @author Lijian 4 * 5 */ 6 public class ThisEscape { 7 //final常量会保证在构造器内完成初始化（但是仅限于未发生this逃逸的情况下，具体可以看多线程对final保证可见性的实现）  8 final int i; 9 //尽管实例变量有初始值，但是还实例化完成 10 int j = 0; 11 static ThisEscape obj; 12 public ThisEscape() { 13 i=1; 14 j=1; 15 //将this逃逸抛出给线程B 16 obj = new ThisEscape(); 17 } 18 public static void main(String[] args) { 19 //线程A：模拟构造器中this逃逸,将未构造完全对象引用抛出 20 /*Thread threadA = new Thread(new Runnable() { 21 @Override 22 public void run() { 23 //obj = new ThisEscape(); 24 } 25 });*/ 26 //线程B：读取对象引用，访问i/j变量 27 Thread threadB = new Thread(new Runnable() { 28 @Override 29 public void run() { 30 31 //可能会发生初始化失败的情况解释：实例变量i的初始化被重排序到构造器外，此时1还未被初始化 32 ThisEscape objB = obj; 33 try { 34 System.</description>
    </item>
    
    <item>
      <title>类加载器和双亲委派模型</title>
      <link>https://HHUsimba.github.io/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 26 May 2020 13:59:53 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</guid>
      <description>类加载器 类加载器（ClassLoader）是Java语言的一项创新，也是Java流行的一个重要原因。在类加载的第一阶段“加载”过程中，需要通过一个类的全限定名来获取定义此类的二进制字节流，完成这个动作的代码块就是类加载器。这一动作是放在Java虚拟机外部去实现的，以便让应用程序自己决定如何获取所需的类。
从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。
从开发者的角度，类加载器可以细分为：
  启动（Bootstrap）类加载器：负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。
  标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。
  应用程序（Application）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。
  除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。
双亲委派模型过程 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</description>
    </item>
    
    <item>
      <title>GC调优策略</title>
      <link>https://HHUsimba.github.io/java/gc%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 25 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/gc%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</guid>
      <description>回收器参数 目前主要有串行、并行和并发三种，对于大内存的应用而言，串行的性能太低，因此使用到的主要是并行和并发两种。并行和并发 GC 的策略通过 UseParallelGC 和 UseConcMarkSweepGC 来指定，还有一些细节的配置参数用来配置策略的执行方式。例如：XX:ParallelGCThreads， XX:CMSInitiatingOccupancyFraction 等。 通常：Young 区对象回收只可选择并行（耗时间），Old 区选择并发（耗 CPU）。
常用 GC 调优策略  GC 调优原则； GC 调优目的； GC 调优策略；  GC 调优原则 在调优之前，我们需要记住下面的原则：
 多数的 Java 应用不需要在服务器上进行 GC 优化； 多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题； 在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）； 减少创建对象的数量； 减少使用全局变量和大对象； GC 优化是到最后不得已才采用的手段； 在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多。
 GC 调优目的 将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。
GC 调优策略 策略 1：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。
策略 2：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。</description>
    </item>
    
    <item>
      <title>GC笔记</title>
      <link>https://HHUsimba.github.io/java/gc%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 03 May 2020 22:59:22 +0800</pubDate>
      
      <guid>https://HHUsimba.github.io/java/gc%E7%AC%94%E8%AE%B0/</guid>
      <description>1 判断对象已经死亡 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。 1.1 引用计数法 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。
public class ReferenceCountingGc { Object instance = null; public static void main(String[] args) { ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; } } 1.2 可达性分析算法 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 1.3 引用 无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。 JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。 JDK1.</description>
    </item>
    
  </channel>
</rss>